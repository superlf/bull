锁的粗化
    多次加锁释放同一个对象
锁的消除
    没有意义的加锁：方法体内的局部对象加锁
锁的膨胀升级
    不可逆
逃逸分析
    不是所有的对象都创建在堆上，有的对象可以创建在栈上
=====================================================
synchronized  内置锁 隐式锁 作用的粒度是对象
    无    锁：
    偏 向 锁：一个线程执行同步块
    轻量级锁：多个线程交替执行,相互竞争不激烈
    重量级锁：多个线程交替执行,相互竞争 激烈

字节码指令
    方法块：monitor
    方法体：ACC_SYNCHRONIZED

对象的组成：
    对象头 + 实例数据 + 填充位数
    对象头 = MarkWord + clazzPoint
    MarkWord  = HashCode + GC + 是否偏向锁 + 是否锁
    对象头：
        无锁：0 + 01
        偏向：1 + 01
        轻量：    00
        重量：    10
        G  C：    11
===========================================================================
ReentrantLock
    自旋 + LocksSuport + CAS + AQS
    公平锁：新加的任务先加入队列
    非公平：先拿锁，拿锁失败加入队列

    exclusiveOwnerThread 当前获取锁的线程是哪个
    state 状态器
        0：初始状态，都可以加锁
    Node 同步等待队列 双向链表 FIFO
        prev 上一个节点
        next 指向上一个节点
        thread 节点的等待线程
        waitStatus 等待状态(信号量)
            signal = -1  //可以被唤醒
            cancelled = 1 //出现异常，中断引起的，需要废弃结束
            condition = -2 //条件等待
            propagate = -3 //传播
            init状态 = 0
    head 队列头
    tail 队列尾

    【公平锁加锁过程】
        1.试图加锁,竞争锁
        2.[前提:加锁失败]把当前线程加入队列 并阻塞
            入队:
            阻塞:试图再获取锁，获锁失败等待唤醒
        3.[前提:加入队列]
        public final void acquire(int arg) {
            if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                selfInterrupt();
        }
    -------------------------------------------------------------------------------------------
    waitestate = 0 -> -1 head 节点为什么改到-1 ?
    因为持有锁的线程T0 在释放锁的时候，得判断head节点waitestate 是否 != 0,
    如果!=0成立，会再把waitstate = -1 -> 0,想要唤醒排队的第一个线程T1，T1被唤醒再继续循环 去抢锁
    在非公平锁，此时可能其他线程T3持有了锁！
    T1可能再次被阻塞，head的节点状态需要再一次经历两轮循环：waitstate = 0 -> -1
    -------------------------------------------------------------------------------------------









